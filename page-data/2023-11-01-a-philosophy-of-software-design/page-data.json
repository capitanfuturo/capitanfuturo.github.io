{"componentChunkName":"component---src-templates-blog-post-js","path":"/2023-11-01-a-philosophy-of-software-design/","result":{"data":{"site":{"siteMetadata":{"title":"Capitanfuturo"}},"markdownRemark":{"id":"1ad17e43-0c7a-5374-b7c6-a3edcbcd02a7","excerpt":"üìö Introduzione Sto recuperando un p√≤ alla volta un lista di libri che avrei sempre voluto leggere per aiutarmi nella mia carriera e nel mio lavoro di tutti‚Ä¶","html":"<h2>üìö Introduzione</h2>\n<p>Sto recuperando un p√≤ alla volta un lista di libri che avrei sempre voluto leggere per aiutarmi nella mia carriera e nel mio lavoro di tutti giorni da sviluppatore, team leader e engineering manager. A philosophy of software dedign √® sicuramente uno di quelli come la serie di Robert c. Martin. Partendo citando il paper di David Parnas del 1971 <a href=\"https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf\">‚ÄúOn the Criteria to be used in Decomposing Systems into Modules‚Äù</a> Ousterhout introduce il suo libro ricordandoci che alcuni concetti seppur di mezzo secolo fa siano attuali sul design del software.</p>\n<p>Leggendo credo che parte della verit√† risieda sul fatto che il nostro processo di risoluzione dei problemi √® tale da rimanere invariante nella storia e che certi concetti siano applicabili in senso lato e non solo nel software. Scrivere un software pulito, clean, e semplice da capire e da manuntenere √® molto difficle. Uno dei problemi principali della computer science √® infatti la <strong>decomposizione</strong>.</p>\n<h2>üöÄ Complessit√†</h2>\n<p>La <strong>modularizzazione</strong> √® alla base delle architetture software. Questo approccio permette di avere dei blocchi di codice isolati tra di loro e possibilmente indipendenti cos√¨ che uno sviluppatore non debba conoscere il contenuto dei moduli ai quali non sta lavorando. Questo semplice concetto √® il mattoncino base delle architetture, √® semplice da capire ma molto difficile da sviluppare. Questo libro mi ha aiutato a fissare alcuni spunti interessanti e pratici.</p>\n<p>A differenza di altre tipologie di progetto, quello software √® caratterizzato da un <strong>cono di incertezza</strong> iniziale e <strong>complessit√†</strong> nel poter visualizzare e immaginare le conseguenze delle scelte di desgin nei sistemi software. Diamo la seguente definizione:</p>\n<blockquote>\n<p>Complessit√† √® qualunque cosa relativa alla struttura di un sistema software che lo renda difficile da modificare e capire.</p>\n</blockquote>\n<p>E per darne una definizione matemetica possiamo usare questa formula per un sitema:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">C = SUM[(c/t)p]</code></pre></div>\n<p>La complessit√† √® la sommatoria della complessit√† (intesa come peso) del singolo componente diviso il tempo impiegato da uno sviluppatore per quel componente.</p>\n<p>Questa complessit√† si manifesta con diversi <strong>sintomi</strong>:</p>\n<ol>\n<li><strong>Change amplification</strong>: ogni modifica, anche semplice, richiede la modifica in diversi punti distanti tra loro.</li>\n<li><strong>Carico cognitivo</strong>: si riferisce alla quantit√† di conoscenza sulla codebase deve avere uno sviluppatore per completare un task. Spesso un‚Äôapproccio dove si incapsula p√π righe di codice pu√≤ aiutare a ridurre il carico cognitivo a patto che la superficie dell‚ÄôAPI sovrastante o la firma del metodo sia ridotta.</li>\n<li><strong>Unknown unknowns</strong>: il terzo sintomo si ha quando non √® evidente cosa modificare per raggiungere il completamento di un task.</li>\n</ol>\n<p>La complessit√† si stratifica nel tempo in piccoli passi ed √® generata principalmente da <strong>2 fattori</strong> :</p>\n<ol>\n<li><strong>Dipendenze</strong>: le dipendenze sono relative a <strong>interfacce</strong> e <strong>implementazioni</strong></li>\n<li><strong>Oscurit√†</strong></li>\n</ol>\n<p>Alcuni consigli per mitigare la complessit√† sono:</p>\n<ul>\n<li>Privilegiare <strong>la strategia sulla tattica</strong>, il codice non deve solo funzionare ma anche essere progettato bene da subito altrimenti si accumula <strong>debito tecnico</strong>.</li>\n<li>Modulizzare in modo che i cambiamenti impattino piccoli pezzi di codice</li>\n<li>Le <strong>interfacce</strong> devono essere semplici ed esporre una <strong>piccola superficie</strong> mentre le <strong>implementazioni</strong> devono essere <strong>profonde</strong> e nascondere la maggior parte o totalit√† della complessit√†. Classi e moduli profonde migliorano l‚Äô<strong>information hiding</strong>. Se un‚Äôinformazione √® nascosta naturalmente non pu√≤ essere parte di una dipendenza. L‚Äôopposto invece aumenta l‚Äô<strong>information leakage</strong> che pu√≤ essere addirittura pericoloso in termini di sicurezza del proprio modulo o classe.</li>\n<li>Le <strong>eccezioni non dovrebbero esistere</strong>: meglio gestire la maggior parte dei casi e ridurre i posti dove vengono gestite le eccezioni.</li>\n<li><strong>Commenti</strong>: La maggior parte sono inutili se possono essere facilmente dedotti dal codice. I commenti di valore sono quelli che descrivono le interfacce perch√® vanno a colmare quegli elementi unknown che non possono essere descritti dal codice di un‚Äôinterfaccia. Inoltre affinch√® siano mantenuti aggiornati √® bene che si trovino <strong>vicino al codice che documentano</strong>. Un buon approccio √® quello di <strong>scriverli da subito</strong>.</li>\n<li>Preferire l‚Äô<strong>approccio general-purpose</strong> e poi implementare per il caso specifico. L‚Äôinterfaccia quindi dovrebbe essere pensata in modo generale per supportare usi multipli.</li>\n<li>Quando si trovano diversi metodi pass-through tra i layer di astrazione del sistema √® consigliabile usare un <strong>oggetto contesto</strong>, che mantenga lo stato da passare piuttosot che esplodere il tutto con firme di metodi piene di argomenti.</li>\n<li><strong>Design it twice</strong>: questo permette di fare challenge sulla prima progettazione in modo da trovare una soluzione sub ottimale in prima istanza senza partire subito con la sua implementazione.</li>\n<li>Crea <strong>precisione e consistenza</strong> nella codebase attraverso:\n<ul>\n<li>un buon <strong>naming</strong> delle varibili</li>\n<li>standard e <strong>convenzioni</strong> di scritttura nel team</li>\n<li><strong>interfacce</strong></li>\n<li><strong>code review</strong></li>\n<li>privilegiare <strong>unit test</strong></li>\n</ul>\n</li>\n</ul>\n<h2>üç∑ Conclusione</h2>\n<h2>ü§ì Riferimento</h2>\n<p>John Ousterhout, <em>A Philosophy of Software Design</em>, Yaknyam Press, 2018. <a href=\"https://www.amazon.it/\">Amazon</a>.</p>\n<blockquote>\n<p>‚ÄúL‚Äôuomo dovrebbe mettere altrettanto ardore nel semplificare la sua vita quanto ce ne mette a complicarla.‚Äù. (Henri Louis Bergson)</p>\n</blockquote>","frontmatter":{"title":"A Philosophy of Software Design (John Ousterhout)","date":"01 November 2023","description":null,"tags":["Libri"]}},"previous":{"fields":{"slug":"/2023-10-01-the-managers-path/"},"frontmatter":{"title":"The Manager's path (Camille Fournier)"}},"next":{"fields":{"slug":"/2023-12-15-refactoring/"},"frontmatter":{"title":"Refactoring: Improving the Design of Existing Code (Martin Fowler)"}}},"pageContext":{"id":"1ad17e43-0c7a-5374-b7c6-a3edcbcd02a7","previousPostId":"df16880f-4a6a-5906-baf0-23ea0c45d3de","nextPostId":"48d51dcf-cb01-5126-a5f8-2a65f09d941e"}},"staticQueryHashes":["2114561082"],"slicesMap":{}}