{"componentChunkName":"component---src-templates-blog-post-js","path":"/2023-12-15-refactoring/","result":{"data":{"site":{"siteMetadata":{"title":"Capitanfuturo"}},"markdownRemark":{"id":"48d51dcf-cb01-5126-a5f8-2a65f09d941e","excerpt":"üìö Introduzione Nella lista dei must da leggere, Martin Fowler √® sempre una certezza. Refactoring √® un manuale pi√π che un libro nel quale vengono illustrati‚Ä¶","html":"<h2>üìö Introduzione</h2>\n<p>Nella lista dei must da leggere, Martin Fowler √® sempre una certezza. Refactoring √® un manuale pi√π che un libro nel quale vengono illustrati diversi pattern per poter affrontare un refactoring di codice legacy. Attenzione per√≤ che il focus √® legato alla <strong>programmazione ad oggetti</strong>.\nDevo dire che fortunatamente dopo quasi 15 anni di programmazione molti pattern sono conosciuti e applicati di default. Per√≤ come al solito, avere un linguaggio comune con cui chiamarli √® d‚Äôaiuto per accordarsi con i dev. D‚Äôaltronde a noi del genere umano piace molto dare il nome alle cose!</p>\n<h2>üöÄ Cosa mi porto a casa da questa lettura</h2>\n<ul>\n<li><strong>Il refactoring √® una attivit√† rischiosa perch√® si va a modificare codice funzionante</strong>. Questo aspetto va preso bene in considerazione perch√® per poter affrontare bene questo processo l‚Äôunica cosa che ci pu√≤ proteggere sono i <strong>test</strong>.</li>\n<li>L‚Äôobiettivo √® quello di <strong>non modificare il comportamento esterno ma migliorare la struttura interna</strong>, perch√® come espresso in libri come clean code e clean architecture di Robert C. Martin un sistema disegnato male √® difficile da mantenere e da modificare</li>\n<li>L‚Äôattivit√† di refactoring dovrebbe essere continua e fatta <strong>ad ogni nuova feature</strong> del codice, in modo che sia fatta per piccoli step e corredata da test. I piccoli step garantiscono che la superficie di impatto sia limitata da controllare. Mentre l‚Äôattivit√† continua implica che nelle stime venga sempre messo in conto anche questa attivit√† altrimenti il business difficilmente finanzier√† questi tipi di attivit√† che non hanno impatto sul cliente finale.</li>\n<li>Il primo refactoring che pu√≤ dare massimo effetto con minimo sforzo √® il <strong>renaming</strong>. Dare il nome giusto a metodi e a variabili rende il codice leggibile anche da chi lo vede per la prima volta.</li>\n<li>E‚Äô bene mantenere vecchi metodi, deprecarli e utilizzare al loro interno quelli nuovi. Sar√† poi successivamente che sar√† possibile eliminare il metodo deprecato.</li>\n<li>La maggior parte dei refactoring tendono a diminuire il codice ma ove non possibile non bisogna aver paura di scrivere pi√π righe di codice. L‚Äôobiettivo √® quello di migliorare la struttura interna del codice. Questo significa che a volte <strong>√® meglio avere un ciclo macchina in pi√π che del codice difficile da mantenere</strong>. In contesti non real time la cpu costa meno degli sviluppatori che devono lavorare su quella codebase.</li>\n<li><strong>Dopo tre volte che duplichi il codice √® meglio estrarlo</strong> in un metodo richiamato dai tre punti.</li>\n<li>Usare l‚Äôindirection (l‚Äôintroduzione di un elemento di <strong>disaccoppiamento</strong> tra due layer) permette di:\n<ul>\n<li>abilitare la condivisione di logica</li>\n<li>rendere esplicita l‚Äôintenzione del progettista e separare l‚Äôimplementazione</li>\n<li>isolare le modifiche</li>\n<li>raggruppare logica condizionale</li>\n</ul>\n</li>\n<li>Le interfacce sono dei strumenti di indirection potenti ma hanno il limite che una volta resi pubbliche o se vogliamo pubblicate il progettista ne perde il controllo perch√© non pu√≤ sapere a priori quali siano le implementazioni. Questo vale soprattutto per i framework e per questo un consiglio √® quello di non pubblicare troppo presto le interfacce.</li>\n<li>Alcuni blocchi che facilmente possono essere considerati oggetto di refactoring sono:\n<ul>\n<li>metodi lunghi</li>\n<li>classi larghe</li>\n<li>firme lunghe</li>\n</ul>\n</li>\n<li>Quando senti il bisogno di scrivere un commento, prova prima a fare del refactoring in modo da rendere superfluo il commento.</li>\n<li><strong>Separa lo strato di dominio da quello di presentazione</strong>.</li>\n<li>I test possono essere integrati nel codice usando in maniera appropriata le Assertion e le Exception. E quando si risolve un bug √® buona norma affiancarlo da un unit test per verificarlo.</li>\n<li>Se si ritiene che un pezzo di codice debba essere riscritto‚Ä¶ a quel punto non ha senso procedere con il refactoring ma semplicemente con la nuova implementazione</li>\n</ul>\n<h3>üí© Elenco dei principali Code Smells</h3>\n<ul>\n<li><strong>Shotgun Surgery</strong>: Una qualsiasi modifica ad una classe implica una serie di mini modifiche in tanti oggetti.</li>\n<li><strong>Feature Envy</strong>: Si ha quando un metodo di una classe tratta principalmente dei dati di un‚Äôaltra classe</li>\n<li><strong>Primitive Obsession</strong>: si ha quando si usano solo campi primitivi invece di strutturare i dati in oggetti</li>\n<li><strong>Switch Statements</strong>: gli switch case sono importanti ma se abusati o molto complessi vale la pena spezzarli in blocchi di if else then. Se si aggiunge una nuova clausola va poi rivisto tutto il flusso dei switch case</li>\n<li><strong>Parallel Inheritance Hierarchies</strong>: avviene quando creando una sottoclasse di una classe c‚Äô√® la necessit√† di creare una sottoclasse di un‚Äôaltra class.</li>\n<li><strong>Lazy Class</strong>: se una classe non viene usata o non fa abbastanza allora vale la pena eliminarla e spostare la logica</li>\n<li><strong>Speculative Generality</strong>: si ha quando si trovano metodi, classi, campi o parametri non usati o pensati per un futuro</li>\n<li><strong>Temporary Field</strong>: si ha quando di un oggetto alcuni campi vengono popolati solo in certe circostanze</li>\n<li><strong>Message Chains</strong>: si ha quando si vede una catena di oggetti che chiamano oggetti in sequenza: a() -> b() -> c()</li>\n<li><strong>Inappropriate Intimacy</strong>: si ha quando una classe usa un metodo o campo interno di un‚Äôaltra classe</li>\n<li><strong>Middle man</strong>: se una classe esegue solo un‚Äôazione allora vale la pena eliminarla. Spesso questa classe far√† solo da tramite verso l‚Äôoggetto che realmente esegue la logica.</li>\n</ul>\n<h3>üîß Elenco delle principali azioni di refactoring</h3>\n<ul>\n<li><strong>Composizione di metodi</strong> per aggregare logica in un solo blocco</li>\n<li><strong>Estrazione a metodo</strong> di parte di logica ripetuta</li>\n<li><strong>Rinominare</strong> metodi, variabili, campi</li>\n<li><strong>Estrarre oggetti</strong> da metodi, da data value o da parametri</li>\n<li>Sostituzione di algoritmi</li>\n<li><strong>Sostituire magic number</strong> con costanti.</li>\n<li><strong>Estrarre interfacce e astrazioni</strong>.</li>\n<li>Introdurre l‚Äô<strong>oggetto Null</strong>.</li>\n<li>Sollevare eccezioni al posto di codici di errore</li>\n<li>Usare le asserzioni</li>\n</ul>\n<h3>üíî Quando non scrivere un refactoring</h3>\n<ol>\n<li>Quando non si sa bene come farlo</li>\n<li>Se i vantaggi a lungo termine non ne valgono la pena</li>\n<li>Se √® troppo costoso</li>\n<li>Se pu√≤ rompere il funzionamento</li>\n</ol>\n<h2>üç∑ Conclusione</h2>\n<p>Martin Fowler √® uno dei pi√π illustri scrittori di ingegneria del software e questo libro √® un must. Pu√≤ sembrare a volte banale per un programmatore scafato ma raccoglie in maniera ordinata tutta una serie di ‚Äúcode smells‚Äù che possono essere risolti per migliorare la struttura del codice.\nUn ottimo strumento da utilizzare alla bisogna e in particolare da abbinare a questo sito che raccoglie anche visivamente delle schede sull‚Äôargomento: <a href=\"https://refactoring.guru/\">Refactoring Guru</a></p>\n<h2>ü§ì Riferimento</h2>\n<p>Martin Fowler, <em>Refactoring: Improving the Design of Existing Code</em>, ¬†Addison-Wesley Professional, 2¬∞ edizione, 2020. <a href=\"https://www.amazon.it/Become-Effective-Software-Engineering-Manager-ebook/dp/B08GF7P3G8/ref=tmm_kin_swatch_0?_encoding=UTF8&#x26;qid=1695987600&#x26;sr=8-2\">Amazon</a>.</p>\n<blockquote>\n<p>‚ÄúAny fool can write code that a computer can understand. Good programmers write code that humans can understand.‚Äù. (Martin Fowler)</p>\n</blockquote>","frontmatter":{"title":"Refactoring: Improving the Design of Existing Code (Martin Fowler)","date":"15 December 2023","description":null,"tags":["Libri"]}},"previous":{"fields":{"slug":"/2023-11-01-a-philosophy-of-software-design/"},"frontmatter":{"title":"A Philosophy of Software Design (John Ousterhout)"}},"next":{"fields":{"slug":"/2023-12-30-obiettivi-2024/"},"frontmatter":{"title":"Obiettivi 2024 e bilancio 2023"}}},"pageContext":{"id":"48d51dcf-cb01-5126-a5f8-2a65f09d941e","previousPostId":"1ad17e43-0c7a-5374-b7c6-a3edcbcd02a7","nextPostId":"26834fdd-166a-5774-af97-2d4863c5c5d6"}},"staticQueryHashes":["2114561082"],"slicesMap":{}}