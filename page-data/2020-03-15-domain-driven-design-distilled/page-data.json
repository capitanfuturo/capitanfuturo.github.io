{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020-03-15-domain-driven-design-distilled/","result":{"data":{"site":{"siteMetadata":{"title":"Capitanfuturo"}},"markdownRemark":{"id":"0b1eec09-52bd-59c9-a18c-7234564b7f6b","excerpt":"üìö Premessa Da un paio di mesi sono coinvolto in un progetto orientato ai micro-servizi e alla costruzione di una piattaforma per supportare tutti i‚Ä¶","html":"<h2>üìö Premessa</h2>\n<p>Da un paio di mesi sono coinvolto in un progetto orientato ai micro-servizi e alla costruzione di una piattaforma per supportare tutti i microservizi corporate del pi√π importante player nella distribuzione di energia elettrica in Italia. Alla base di questo processo aziendale c‚Äô√® l‚Äôacquisizione e la declinazionesul campo della teoria del Domain-Driven Design (da ora in poi abbreviato in DDD).\nLa DDD nasce dalla mente di Eric Evans ed √® descritta nel libro <em>Domain-Driven Design: Tackling Complexity in the Heart of Software</em>. Per iniziare ad addentrarsi nell‚Äôargomento invece ho deciso di partire da <em>Domain-Driven Design Distilled</em> di Vaugh Vernon. Questo testo pu√≤ fare al caso, con alcuni ma, che descriver√≤ in seguito.</p>\n<h2>Appunti di Domain-Driven Design Distilled</h2>\n<p>La domain-driven design √® un insieme di strumenti che permettono di modellare il software. Il fulcro del design √® alla modellazione del <em>dominio</em> da descrivere nella maniera pi√π esplicita possibile ed √® proprio questo concetto il pi√π arduo da spiegare.\nLe tecniche della DDD partono da un prerequisito forte: il cambio organizzativo e non solo concettuale basato sulle seguenti osservazioni nel mondo business reale:</p>\n<ul>\n<li>Lo sviluppo del software √® considerato un centro di costo e non un centro di profitto.</li>\n<li>Gli sviluppatori sono spesso orientati alle tecnologie e non al design e al dominio.</li>\n<li>Il database ha un ruolo troppo centrale e il modello dati tende ad avere pi√π importanza rispetto ai processi di business.</li>\n<li>I servizi forniti sono spesso troppo accoppiati tra di loro</li>\n</ul>\n<p>A partire da queste considerazioni l‚Äôautore identifica due modalit√† di disegno:</p>\n<ol>\n<li>Strategic design</li>\n<li>Tactical design</li>\n</ol>\n<h3>Strategic design</h3>\n<p>Il primo strumento da introdurre come condizione sine qua non per poter comprendere il tactical design √® lo strategic design. Il primo passo √® usare il pattern Bounded Context per segregare i modelli di dominio e allo stesso tempo sviluppare un Ubiquitous Language associato al modello di dominio all‚Äôinterno di un Bounded Context.\nUn <strong>Bounded Context</strong> √® un perimetro semantico contestuale: ogni componente al suo interno ha un significato specifico e fa delle cose specifiche per quel contesto semantico. All‚Äôinterno di questo contesto esiste un linguaggio specifico e rigoroso utilizzato dai membri del team e che sta sotto il nome di <strong>Ubiquitous Language</strong>.\nQuesto implica che lo stesso termine possa avere diverse accezioni in Bounded Context diversi ed inoltre forza il team a concentrarsi su quello che √® il cuore del contesto lasciando quello che rimane fuori come parte del Ubiquitous Language.\nQuello che rimane fuori dal core, che chiamiamo <strong>Core Domain</strong> andr√† via via a descrivere attraverso ubiquitous language specifici dei nuovi Bounded Context.\nPer sviluppare un Ubiquitous Language viene consigliato l‚Äôuso di diverse sessioni di <strong>Event Storming</strong> nelle quali emergono i Bounded Context a partire dagli eventi di business che si identificano. La descrizione di scenari di funzionamento del modello aiuta a definire i contesti e i modelli di dominio che si vanno a delineare. Questa tecnica nella quale si parte dal comportamento del modello si chiama <strong>Behavior-Driven Development</strong> (BDD).\nPer poter validare il modello di dominio sui vari scenari si possono descrivere dei test di accettazione. I test sono naturalmente scrivibili a partire dallo scenario e validano il dominio stesso.</p>\n<h4>Architettura</h4>\n<p>Un Bounded Context √® composto da tre livelli:</p>\n<ol>\n<li><strong>Input Adapters</strong> come GUI, REST endpoints</li>\n<li><strong>Application Services</strong> che orchestrano gli use case e gestiscono le transazioni.</li>\n<li>Il <strong>Dominio</strong> sul quale il libro si focalizza.</li>\n<li><strong>Output Adapters</strong> come la gestione della persistenza e dell‚Äôinvio di messaggi.</li>\n</ol>\n<p>Dati gli starti di cui sopra √® possibile usare il DDD con una qualunque di queste architetture e pattern:</p>\n<ul>\n<li><strong>Event-Driven Architecture</strong>; Event Sourcing.</li>\n<li>Command Query Responsibility Segregation (<strong>CQRS</strong>).</li>\n<li><strong>Reactive and Actor Model</strong>.</li>\n<li>Representational State Transfer (<strong>REST</strong>).</li>\n<li>Service-Oriented Architecture (<strong>SOA</strong>).</li>\n<li><strong>Microservices</strong> sono essenzialmente equivalenti ai Bounded Context.</li>\n<li><strong>Cloud computing</strong>.</li>\n</ul>\n<h4>Subdomains</h4>\n<p>Un subdomain √® una sottoparte di tutto il dominio di business. Si pu√≤ pensare ad un subdomain coma un singolo, logico modello di dominio. Solitamente per un subdomain si designano uno o pi√π esperti di dominio, <strong>Domain Experts</strong> che comprendono molto bene gli aspetti di business di quel specifico sotto dominio.</p>\n<h4>Tipi di Sottodomini</h4>\n<ol>\n<li><strong>Core domain</strong> √® il sottodominio pi√π importante, essenziale per il business senza il quale il business non esiste. Solitamente √® il primo da individuare e modellare.</li>\n<li><strong>Supporting subdomain</strong> √® un sottodominio meno importate e di meno valore per il business ma senza il quale il business non pu√≤ sopravvivere per molto tempo. In questo caso non √® consigliabile affidarsi a soluzioni o componenti ‚Äúbuy‚Äù.</li>\n<li><strong>Generic subdomain</strong> sono di meno valore e talmente generici che si possono considerare soluzioni proprietarie.</li>\n</ol>\n<h4>Context Mapping</h4>\n<p>Insieme al core domain esistono altri bounded context e sottodomini. Un modo per modellare la comunicazione tra questi contesti differenti √® l‚Äôutilizzo del <strong>Context Mapping</strong>. Due bounded context hanno due ubiquitous language differenti: un context mapping √® la traduzione di un termine da un contesto ad un altro.</p>\n<h4>Tipi di mappatura</h4>\n<ol>\n<li><strong>Partnership</strong>: ogni team √® responsabile di un bounded context. I due team con obiettivi diversi creano una collaborazione di durata variabile a seconda dell‚Äôopportunit√† in modo da allinearsi in modo tale che o falliscono o vincono insieme.</li>\n<li><strong>Shared Kernel</strong>: l‚Äôintersezione tra due bounded context √® non nulla e quindi si condivide una parte di contesto. Questa soluzione √® difficile da mantenere nel tempo perch√® implica una comunicazione aperta tra i team.</li>\n<li><strong>Customer-Supplier</strong>: descrive una relazione tra contesti e team dove il Supplier √® fornitore e Customer cliente delle informazioni.</li>\n<li><strong>Conformist</strong>: si ha quando il team supplier non ha bisogni specifici di supportare il customer. Il customer lato suo non ha possibilit√† di sostenere la traduzione verso il proprio ubiquitous language e quindi si uniforma a quello del supplier.</li>\n<li><strong>Anticorruption Layer</strong>: √® la mappatura pi√π difensiva. Si crea un layer di transcodifica tra i due linguaggi.</li>\n<li><strong>Open Host Service</strong> definisce un protocollo o interfaccia pubblica che da accesso al bounded context come insieme di servizi.</li>\n<li><strong>Published Language</strong> √® un linguaggio di interscambio ben documentato. Spesso un open host service serve e consuma un published language.</li>\n<li><strong>Separate Ways</strong> descrive una sistuazione nella quale l‚Äôintegrazione tra bounded context non produce valore.</li>\n</ol>\n<h3>Deriva del modello</h3>\n<p>Una delle possibili derive del modello, dovuta a context mapping incontrollati √® quella che viene chiamata <strong>Big Ball of Mud</strong>:</p>\n<ol>\n<li>Un numero crescente di aggregati cross domini contaminano i contesti creando dipendenze.</li>\n<li>Mantenere questa struttura causa un impatto su tutti i contesti.</li>\n<li>Solamente un linguaggio non pi√π specifico per dominio mantiene in piedi il modello rendendolo di fatto non pi√π un DDD.</li>\n</ol>\n<h3>Tactical design</h3>\n<p>Il secondo strumento di modellazione da applicare dopo il Strategic design √® il Tactical, che descrive come far comunicare i contesti, come fornire degli aggregati e definisce il concetto di entit√† di dominio e value object.</p>\n<h4>Entity</h4>\n<p>Una Entit√† modella una singola cosa del contesto. Ogni entit√† ha un‚Äôidentit√† univoca che la distingue da tutte le altre entit√† dello stesso tipo o di altri tipi.</p>\n<h4>Value Object</h4>\n<p>Un Value Object modella un concetto atomico immutabile e quindi nel modello il value non √® altro che un valore. A differenza delle entit√† non ha un identificativo univoco.</p>\n<h4>Aggregate</h4>\n<p>Un Aggregate √® composto da una o pi√π Entit√†, quando ce n‚Äô√® solo una si chiama <strong>Aggregate Root</strong>. Oltre alle entit√† possono concorrere anche dei value object in un aggregato. All‚Äôinterno di un singolo aggregato tutte le parti devono essere consistenti, in accordo con le regole di business e ci√≤ implica che un aggregate forma un <strong>Transactional Consinstency Boundary</strong>.\nPer modellare un aggregate possiamo fare riferimento a queste 4 regole generiche:</p>\n<ol>\n<li>Proteggere i concetti invarianti all‚Äôinterno del perimetro dell‚Äôaggregato</li>\n<li>Disegnare aggregati piccoli</li>\n<li>Referenziare altri aggregati solo attraverso l‚Äôidentificatore univoco</li>\n<li>Aggiornare gli altri aggregati usando la <strong>eventual consistency</strong>\nUn altra aspetto da tenere in considerazione √® il <strong>Single Responsibility Principle</strong> (SRP). Se un aggregato sta proavndo a fare troppe cose allora va diviso. Inoltre √® bene tenere a mente di non modificare istanze di aggregati diversi nella stessa transazione.\nAd ogni transazione dell‚Äôaggregato viene pubblicato un <strong>Domain Event</strong>. I Domain Events sono pubblicati da un aggregate e sottoscritti dai bounded context interessati.</li>\n</ol>\n<h4>Anemic Domain Model</h4>\n<p>Un‚Äôaltra deriva del modello √® l‚ÄôAnemic Domain Model nel quale si usa un modello di dominio orientato ad oggetti, ogni oggetto √® un oggetto pubblico con getter e setter e non contiene nessun comportamento di business.\nCi√≤ accade se si applica un focus troppo tecnico e non orientato al business. Il dominio deve descrivere il business.</p>\n<h4>Domain Events</h4>\n<p>Un evento di dominio √® un record di un‚Äôoccorenza di business significativa in un bounded context. La creazione e la pubblicazione ordinata di eventi di dominio garantiscono che il contesto rimanga coerente. L‚Äôevento pu√≤ essere arricchi to di informazioni oltre agli identificativi univoci in modo da rendere il contenuto dell‚Äôevento d‚Äôaiuto chi vi si sottoscrive. E‚Äô importante che l‚Äôaggregate modificato e l‚Äôevento di dominio sia salvato insieme nella stessa transazione. Se si usa la tecnica dell‚Äô<strong>Event Sourcing</strong> allora lo stato dell‚Äôaggregate √® interamente rappresentato dagli stessi eventi di dominio.\nL‚Äôordine corretto di processamento √® data al consumatore dell‚Äôevento che sa fino a che punto a processato gli eventi pubblicati e per i quali era in ascolto.</p>\n<h3>Event Sourcing</h3>\n<p>Event Sourcing pu√≤ essere descritto come il rendere persistenti tutti gli eventi di dominio. Il registro degli eventi permetti quindi di ricostruire lo stato attuale di un aggregate come la sequenza degli eventi che lo hanno interessato.</p>\n<h2>Considerazioni</h2>\n<p>Il libro, come dichiarato dallo stesso autore non √® esaustivo ed √® una reference con la quale iniziare ad addentrarsi nell‚Äôargomento. Quello che pi√π mi ha perplesso √® che i concetti vengono introdotti con un un unico esempio di modellazione di un team Agile e spesso alcuni termini vengono spiegati molto dopo esser stati usati causando dubbi al lettore che non sempre vengono dipanati.\nViceversa il concetto di base che pi√π mi ha colpito √® che alla base di tutto sta il fatto che <strong>sviluppatori ed analisti funzionali parlano la stessa lingua</strong>! Questo significa che agli sviluppatori viene richiesto di conoscere gli aspetti di dominio mentre agli analisti le tecnologie che declinano il dominio. Questa √® un‚Äôaffermazione molto forte che nelle realt√† lavorative trova poco riscontro, almeno nella realt√† italiana.\nIn definitiva non mi sentirei di consigliare la lettura di questo testo senza aver letto almeno qualche articolo sull‚Äôargomento, almeno per non trovarsi spiazzato di fronte a termini che vengono lasciati scontati per troppo tempo nel testo.\nSpero personalmente di poter approfondire questi concetti e di poter trovare situazioni in cui sia possibile usare queste metodologie che richiedono un forte coinvolgimento del cliente o semplicemente del business aziendale.</p>\n<h2>Riferimento</h2>\n<p>Vaughn Vernon, <em>Domain-Driven Design Distilled</em>, Addison-Wesley Professional, 2016. <a href=\"https://www.amazon.it/Domain-Driven-Design-Distilled-English-Vaughn-ebook/dp/B01JJSGE5S/ref=tmm_kin_swatch_0?_encoding=UTF8&#x26;qid=1579193749&#x26;sr=8-1\">Amazon</a></p>\n<blockquote>\n<p>Il design deve funzionare, l‚Äôarte no. (Donald Judd)</p>\n</blockquote>","frontmatter":{"title":"Domain-Driven Design Distilled. (Vaughn Vernon)","date":"15 March 2020","description":null,"tags":["Libri"]}},"previous":{"fields":{"slug":"/2020-03-01-arduino-antirimbalzo/"},"frontmatter":{"title":"Arduino e pulsanti bistabili. La funzione di anti-rimbalzo"}},"next":{"fields":{"slug":"/2020-04-01-saldatore/"},"frontmatter":{"title":"Imparare a saldare"}}},"pageContext":{"id":"0b1eec09-52bd-59c9-a18c-7234564b7f6b","previousPostId":"fc3222a1-e7c6-5508-9954-3909053f009f","nextPostId":"393f892b-9f36-5234-abf3-69b47d64f50c"}},"staticQueryHashes":["2114561082"],"slicesMap":{}}