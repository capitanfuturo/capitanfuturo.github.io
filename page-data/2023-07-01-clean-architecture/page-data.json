{"componentChunkName":"component---src-templates-blog-post-js","path":"/2023-07-01-clean-architecture/","result":{"data":{"site":{"siteMetadata":{"title":"Capitanfuturo"}},"markdownRemark":{"id":"5242b854-d2ac-5bcc-a33b-77b8cb3cbd65","excerpt":"üìö Introduzione Robert Cecil Martin √® uno dei pi√π autorevoli scrittori di libri dedicati all‚Äôarte della programmazione. Nell‚Äôindustry √® conosciuto come il‚Ä¶","html":"<h2>üìö Introduzione</h2>\n<p>Robert Cecil Martin √® uno dei pi√π autorevoli scrittori di libri dedicati all‚Äôarte della programmazione. Nell‚Äôindustry √® conosciuto come il fantomatico <strong>Uncle Bob</strong>. Quest‚Äôanno dopo quasi 12 anni di lavoro in questa industry ho deciso di ripercorrere i ‚Äúclassici‚Äù leggendoli uno ad uno. Ho sempre letto articoli ed esempi su specifici passi di questi libri ma credo che per poter migliorare me stesso nel lavoro sia giusto dedicare del tempo alla lettura.</p>\n<p>Ho iniziato dall‚Äôultimo libro, Clean Architecture, un p√≤ perch√® con il tempo questi libri perdono di grip sull‚Äôattuale e un p√≤ perch√® mi sono trovato di fronte a sfide professionali legate a questo ruolo.</p>\n<p>Al momento sono coinvolto nel refactoring di un monolite venduto con modello di business SaaS ad un sistema distribuito a microservizi e quindi spinto dall‚Äôurgenza ho fatto questa scelta.</p>\n<h2>üöÄ Cosa mi porto a casa da questa lettura</h2>\n<p>Da questo libro mi porto a casa una strutturata descrizione degli utlimi 20 anni di programmazione e degli ultimi trend. Pattern e nomenclatura per poter discutere in ambito tecnico alcune delle scelte necessarie per produrre valore.</p>\n<ul>\n<li>Un‚Äôarchitettura software rappresenta le scelte fatte per costruire un sistema e la sua cifra √® il costo che deve essere applicato per modificarlo, buildare e manuntenerlo. <strong>Pi√π un‚Äôarchitettura √® semplice da modificare, deployare, manuntenere pi√π √® disegnata bene</strong>.</li>\n<li>Nonostante il cono di incertezza che spesso ci √® posto davanti alcuni percorsi e pattern ci possono aiutare a strutturare meglio la nostra architettura. Ogni cosa comunque ha il suo trade-off ma le regole di architettura rimangono per lo pi√π invariate al variare del contesto e del business</li>\n<li>Anche gli sviluppatori sono degli stakeholder del prodotto</li>\n</ul>\n<h3>Paradigmi di programmazione</h3>\n<ol>\n<li><strong>Structured programming</strong> (Edsger Wybe Dijkstra nel 1968) che impone disciplina sul direct transfer of control</li>\n<li><strong>Object Oriented Programming</strong> (Ole Johan Dahl and Kristen Nygaard nel 1966) che impone disciplina sul indirect transfer of control. Le propriet√† principali sono:\n<ul>\n<li>encapsulation</li>\n<li>inheritance</li>\n<li>polymorphism, che ci porta al concetto di <strong>dependancy inversion</strong></li>\n</ul>\n</li>\n<li><strong>Functional programming</strong> (Alonzo Church nel 1936) impone disciplina sulle assegnazioni perch√® in linea teorica non sono previste in questo tipo di programmazione e le variabili sono immutabili. I principali vantaggi di questo paradigma sono:\n<ul>\n<li>NO race conditions</li>\n<li>NO deadlock conditions</li>\n<li>NO concurrent update</li>\n</ul>\n</li>\n</ol>\n<h3>Principi di Code Design - SOLID</h3>\n<ol>\n<li><strong>Single responsibility principle</strong>: una classe dovrebbe avere una e una sola ragione per cambiare o per capire meglio un modulo dovrebbe essere responsabile di una ed una sola attivit√†.</li>\n<li><strong>Open-closed principle</strong>: una classe dovrebbe essere aperta all‚Äôestensione ma chiusa alla modifica. Questo implica che un‚Äôestensione non deve poter modificare le logiche interne della classe.</li>\n<li><strong>Liskov‚Äôs substitution principle</strong>: gli oggetti in un programma dovrebbero essere sostituibili da istanze dei propri sottotipi senza alterare il comportamento del programma. Anche questo principio descrive come il disaccoppiamento e le dipendenze devono essere per lo pi√π a livello di interfacce e non di implementazioni.</li>\n<li><strong>Interface segregation principle</strong>: meglio separare le interfacce per propriet√† specifiche che non interfacce generiche.</li>\n<li><strong>Dependency inversion principle</strong>: le dipendenze dovrebbero avvenire sulle astrazioni e non sulle classi concrete.</li>\n</ol>\n<h3>Principi dei Componenti</h3>\n<p>I componenti sono unit√† di deployment come jar, DLL o servizi e su queste entit√† possiamo individuare 3 principi per la coesione del componente:</p>\n<ol>\n<li><strong>RRP - Reuse / Release Equivalence Principle</strong>: la granularit√† del riuso √® uguale alla granularit√† del rilascio.</li>\n<li><strong>CCP - Common Closure Principle</strong>: raggruppa nei componenti quelle classi che cambiano per lo stesso motivo nello stesso tempo. Questo si lega al SRP - single responsability principle.</li>\n<li><strong>CRP - Common Reuse Principle</strong>: non forzare l‚Äôutilizzatore di un componente a dipendere da cose che non necessita, legato al ISP - interface segregation principle.\nQuesti 3 principi possono essere disposti un diagramma di tensione, un triangolo nel quale i componenti si collocano. In generale non si possono ottenere contemporaneamente i 3 principi ma un trade-off dei 3 a seconda delle necessit√†.</li>\n</ol>\n<p>Altri 3 principi esposti sono:</p>\n<ol>\n<li><strong>Acyclic dependencies principle</strong>: non ci devono essere cicli nel grafo delle dipendenze. Per risolvere eventuali cicli si pu√≤ usare il principio di inversione delle dipendenze.</li>\n<li><strong>Stable dependency principle</strong>: i componenti meno stabili dovrebbero dipendere da componenti pi√π stabili.\n<strong>Stability</strong>¬†= (numero di dipendenze in uscita) / (somma delle dipendenze in uscita e in ingresso)</li>\n<li><strong>Stable abstractions principle</strong>: i componenti stabili dovrebbero essere delle astrazioni. Un esempio √® una policy di alto livello che pu√≤ essere modificata da un‚Äôestensione seuendo il principio del open-closed principle.\n<strong>Abstractness</strong>¬†= (numero di classi astratte e interfacce) / (totale numero di classi e interfacce)</li>\n</ol>\n<h3>Principi di architettura</h3>\n<ul>\n<li>Un <strong>architetto deve continuare ad essere un programmatore</strong> per non avere troppo distacco dalle tematiche tecniche.</li>\n<li>Gli aspetti da tenere a mente per una buona architettura sono:\n<ul>\n<li><strong>development</strong></li>\n<li><strong>deployment</strong></li>\n<li><strong>operation</strong></li>\n<li><strong>maintenance</strong></li>\n</ul>\n</li>\n<li>Le regole di business non devono dipendere dalle scelte tecniche. Per fare questo un approccio √® quello di <strong>definire i confini</strong> e separare in layer sia per <strong>livelli logici</strong> che per per <strong>casi d‚Äôuso</strong>.</li>\n</ul>\n<p>L‚Äôarchitettura dovrebbe avere le seguenti caratteristiche:</p>\n<ul>\n<li>Testabile</li>\n<li>Indipendente dai framework</li>\n<li>Indipendente dalla UI</li>\n<li>Indipendente dal tipo di database</li>\n<li>Indipendente da agenti esterni</li>\n</ul>\n<p>Un buon punto di partenza √® l‚Äô<strong>architettura esagonale</strong> proposta da Alistair Cockburn nel 2005.</p>\n<h2>üç∑ Conclusione</h2>\n<p>Libro da leggere per mettere in ordine dei concetti spesso nominati senza un filo conduttore. L‚Äôautore √® un guru della tematica e mi √® piaciuto molto leggerlo, soprattutto nella parte iniziale nella quale descrive come certi pattern e paradigmi siano nati dall‚Äôuso della tecnologia stessa, dai primi compilatori agli assembler.</p>\n<p>Forse nonostante sia del 2017 questo libro sa di datato per alcune cose, nel senso che tecnologie serverless e cloud probabilmente sono pi√π attuali del linguaggio ad oggetti per√≤ i principi fondamentali rimangono invariati.</p>\n<h2>ü§ì Riferimento</h2>\n<p>Robert C. Martin, <em>Clean Architecture</em>, Addison-Wesley, 2017. <a href=\"https://www.amazon.it/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164/ref=sr_1_1?keywords=clean+architecture&#x26;qid=1682951643&#x26;sprefix=clean+ar%2Caps%2C148&#x26;sr=8-1\">Amazon</a>.</p>\n<blockquote>\n<p>‚ÄúThe only way to go fast, is to go well‚Äù (Robert C. Martin)</p>\n</blockquote>","frontmatter":{"title":"Clean Architecture (Robert C. Martin)","date":"01 July 2023","description":null,"tags":["Libri"]}},"previous":{"fields":{"slug":"/2023-06-01-homo-deus/"},"frontmatter":{"title":"Homo Deus (Harari)"}},"next":{"fields":{"slug":"/2023-08-01-software-architecture-patterns/"},"frontmatter":{"title":"Software Architecture Patterns (Mark Richards)"}}},"pageContext":{"id":"5242b854-d2ac-5bcc-a33b-77b8cb3cbd65","previousPostId":"0dc8ff1f-98ea-5302-9fe9-babb319dc415","nextPostId":"3d90753e-2c56-5879-9b02-abb8ab11d977"}},"staticQueryHashes":["2114561082"],"slicesMap":{}}