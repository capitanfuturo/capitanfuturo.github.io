{"componentChunkName":"component---src-templates-blog-post-js","path":"/2023-08-01-software-architecture-patterns/","result":{"data":{"site":{"siteMetadata":{"title":"Capitanfuturo"}},"markdownRemark":{"id":"3d90753e-2c56-5879-9b02-abb8ab11d977","excerpt":"ğŸ“š Introduzione Tra le letture tecniche che ho scelto questâ€™anno figura anche questa di Mark Richards. Mark Ã¨ un software architect con quasi 30 di esperienzaâ€¦","html":"<h2>ğŸ“š Introduzione</h2>\n<p>Tra le letture tecniche che ho scelto questâ€™anno figura anche questa di Mark Richards. Mark Ã¨ un software architect con quasi 30 di esperienza nellâ€™industry ed in particolare 20 tra application architect, integration architect ed enterprise architect. In questo libro illustra in maniera semplice 5 delle architetture piÃ¹ facilmente ritrovabili nei progetti di tutti i giorni.  Il libro non va nei dettagli tecnici ma da un buon punto di inizio per poter scegliere quale strada perseguire a seconda del caso dâ€™uso che abbiamo di fronte.</p>\n<h2>ğŸš€ Cosa mi porto a casa da questa lettura</h2>\n<p>Mark descrive le principali architetture in auge in questo momento tra sistuazioni on-premise e in cloud. Unâ€™applicazione senza unâ€™architettura definita spesso ricade in quella che viene chiamata <strong>big ball of mud</strong> nella quale i componenti sono accoppiati, rigidi e con elevati costi per le modifiche. I pattern principali che lâ€™autore propone sono 5:</p>\n<ol>\n<li>Layered architecture</li>\n<li>Event-driven architecture</li>\n<li>Microkernel architecture</li>\n<li>Microservices architecture</li>\n<li>Space-based architecture</li>\n</ol>\n<h3>Layered architecture</h3>\n<p>Forse la piÃ¹ conosciuta e storica architettura, chiamata anche n-tier.  Si tratta di tagliare i componenti in <strong>strati orizzontali</strong> e per ogni strato incapsulare logiche di specifiche funzioni come ad esempio:</p>\n<ol>\n<li>Presentation layer</li>\n<li>Business layer</li>\n<li>Persistence e database layer</li>\n</ol>\n<p>Questa struttura ha il pregio di separare chiaramente i compiti di ogni livello. Robert Martin (Uncle Bob) propone anche di tagliare verticalmente lâ€™architettura per casi dâ€™uso.</p>\n<p>Ci possono essere dei casi in cui uno strato Ã¨ aperto oltre che agli strati adiacenti anche ad altri. Questo Ã¨ il caso di livelli di servizio, con componenti condivisi. Ovvio che il rilassamento di questo vincolo porta ad accoppiamento monolitico dellâ€™applicazione.</p>\n<p>Questa architettura Ã¨ una buona scelta iniziale, Ã¨ general purpose e si adatta bene allâ€™inizio. Le due considerazioni sono quelle di:</p>\n<ul>\n<li>non avere livelli asfittici, intesi come meri passa carte</li>\n<li>non accoppiare troppo i livelli per non creare un monolite</li>\n</ul>\n<h3>Event-driven architecture</h3>\n<p>Lâ€™architettura ad eventi Ã¨ un pattern di <strong>architettura asincrona distribuita</strong> usata per applicazioni altamente scalabili. I componenti che processano gli eventi sono dei processori single-purpose. Esistono 2 principali topologie:</p>\n<ol>\n<li><strong>Mediator</strong>: usato per orchestrare step multipli. Il mediatore centrale riceve lâ€™evento e ne genera altri per pilotare i singoli step. Si possono quindi identificare due eventi principali: lâ€™evento iniziale e lâ€™evento di processamento.</li>\n<li><strong>Broker</strong>: qui ogni processore puÃ² essere consumatore ed emettitore di eventi senza necessitÃ  di un mediatore centrale.</li>\n</ol>\n<h3>Microkernel architecture</h3>\n<p>Lâ€™architettura a microkernel o anche a plug-in Ã¨ una pattern naturale per le applicazioni di prodotto. PuÃ² essere distribuita in pacchetti con versioni diverse ed inglobare codice di terze parti. Lâ€™idea alla base di questa architettura Ã¨ quella di costruire:</p>\n<ul>\n<li>un kernel applicativo</li>\n<li>un registro dei plugin</li>\n<li>delle interfacce per registrare i plugin ed installarli nel microkernel</li>\n</ul>\n<p>Un esempio Ã¨ quello di Eclipse o di VSCode.</p>\n<h3>Microservices architecture</h3>\n<p>Lâ€™architettura  a microservizi Ã¨ quella piÃ¹ in voga negli ultimi tempi perchÃ¨ vuole superare i limiti di scalabilitÃ  dei monoliti a layer e dei pattern SOA, service oriented architecture. La sfida Ã¨ quella di disegnare in maniere corretta questi microservizi, determinandone il giusto livello di granularitÃ  e senza necessitare di elementi di orchestrazione che appesantiscono lâ€™architettura come avveniva per le architetture SOA.</p>\n<p>Altro aspetto da tenere presente Ã¨ la gestione delle transazioni distribuite su componenti diversi. Spesso per ottenere questo risultato sono necessarie prevedere delle operazioni compensative in caso di rollback logico.</p>\n<p>Altri aspetti da considerare sono la governance dei contratti API, la gestione della mancata disponibilitÃ  dei servizi (circuit-braker, retry backoff) e la gestione dellâ€™autenticazione e autorizzazione.</p>\n<h3>Space-based architecture</h3>\n<p>Lâ€™architerrura space-based Ã¨ pensata nello specifico per risolvere problemi di scalabilitÃ  e concorrenza. Eâ€™ inoltre valida per gestire carichi non prevedibili. Spesso Ã¨ identificabile con il pattern dellâ€™architettura cloud. Lâ€™idea alla base Ã¨ quella dellâ€™uso di memoria condivisa distribuita.</p>\n<p>Gli elementi di questa architettura sono:</p>\n<ul>\n<li><strong>message grid</strong>: per la gestione dei messaggi e delle sessioni in ingresso. PuÃ² anche essere usato per orchestare le unitÃ  di processamento</li>\n<li><strong>data grid</strong>: per il caricamento e sincronizzazione in memoria della persistenza</li>\n<li><strong>processing grid</strong>: che applica la business logic</li>\n<li><strong>deployment-manager component</strong>: incaricato di scalare le unitÃ  di processamento in modo orizzontale</li>\n</ul>\n<h3>Pattern-analysis summary</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"center\">layer</th>\n<th align=\"center\">event driven</th>\n<th align=\"center\">microkernel</th>\n<th align=\"center\">micoservice</th>\n<th align=\"center\">space-based</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Modifiche</td>\n<td align=\"center\">ğŸŸ¥</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ©</td>\n</tr>\n<tr>\n<td>Rilascio</td>\n<td align=\"center\">ğŸŸ¥</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ©</td>\n</tr>\n<tr>\n<td>TestabilitÃ </td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ¥</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ¥</td>\n</tr>\n<tr>\n<td>Performance</td>\n<td align=\"center\">ğŸŸ¥</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ¥</td>\n<td align=\"center\">ğŸŸ©</td>\n</tr>\n<tr>\n<td>ScalabilitÃ </td>\n<td align=\"center\">ğŸŸ¥</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ¥</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ©</td>\n</tr>\n<tr>\n<td>Sviluppo</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ¥</td>\n<td align=\"center\">ğŸŸ¥</td>\n<td align=\"center\">ğŸŸ©</td>\n<td align=\"center\">ğŸŸ©</td>\n</tr>\n</tbody>\n</table>\n<h2>ğŸ· Conclusione</h2>\n<p>Libro scorrevole come difficilmente si trovano tra i libri tecnici. Non Ã¨ molto dettagliato ma fa il suo dovere nel senso che permette di avere una panoramica precisa su una possibile scelta di architettura di massima. Lâ€™ho trovato interessante proprio per la sua chiarezza senza tanti fronzoli ma efficace nello scopo.</p>\n<h2>ğŸ¤“ Riferimento</h2>\n<p>Mark Richards, <em>Software Architecture Patterns</em>, Oâ€™Reilly, 2015.</p>\n<blockquote>\n<p>â€œAll architectures become iterative because of unknown unknowns, Agile just recognizes this and does it soonerâ€. (Mark Richards)</p>\n</blockquote>","frontmatter":{"title":"Software Architecture Patterns (Mark Richards)","date":"01 August 2023","description":null,"tags":["Libri"]}},"previous":{"fields":{"slug":"/2023-07-01-clean-architecture/"},"frontmatter":{"title":"Clean Architecture (Robert C. Martin)"}},"next":{"fields":{"slug":"/2023-09-01-the-obstacle-is-the-way/"},"frontmatter":{"title":"The Obstacle Is the Way: The Timeless Art of Turning Trials into Triumph (Ryan Holiday)"}}},"pageContext":{"id":"3d90753e-2c56-5879-9b02-abb8ab11d977","previousPostId":"5242b854-d2ac-5bcc-a33b-77b8cb3cbd65","nextPostId":"29419202-8a7e-56dc-9fac-05473716b461"}},"staticQueryHashes":["2114561082"],"slicesMap":{}}